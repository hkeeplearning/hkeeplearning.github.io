<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>常用设计模式总结</title>
    <url>/posts/2602918917/</url>
    <content><![CDATA[<p>设计模式是编码的一种经验总结，通过设计模式我们可以实现通用性好，易于扩展，方便维护的接口。</p>
<a id="more"></a>

<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="Pimpl惯用法"><a href="#Pimpl惯用法" class="headerlink" title="Pimpl惯用法"></a><code>Pimpl</code>惯用法</h3><p>隐藏内部细节。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// autotimer.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_WIN32) || defined(_WIN64)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">IMG_BEGIN_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoTimer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AutoTimer();</span><br><span class="line">    ~AutoTimer();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">GetElapsed</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_WIN32) || defined(_WIN64)</span></span><br><span class="line">	DWORD mStartTime;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">mStartTime</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>    </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IMG_END_NAMESPACE</span><br></pre></td></tr></table></figure>

<p>实现这个类的目的只是为了获取对象从构造到销毁之间的运行时间，与程序在是什么平台上跑完全没有关系吧。在这个头文件中暴露了太多的细节，破坏了接口的简洁性。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// autotimer.h</span></span><br><span class="line">IMG_BEGIN_NAMESPACE</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoTimer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    AutoTimer();</span><br><span class="line">    ~AutoTimer();</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Impl</span>;</span> <span class="comment">//! 声明为私有，在CPP文件里的其他类或者自由函数不能访问Impl</span></span><br><span class="line">    Impl *mImpl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IMG_END_NAMESPACE</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// IMG_SYSTEM_STATE_HPP_H_</span></span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// autotimer.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_WIN32) || defined(_WIN64)</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    </span><br><span class="line">IMG_BEGIN_NAMESPACE</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoTimer</span>:</span>:Impl</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">GetElapsed</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_WIN32) || defined(_WIN64)</span></span><br><span class="line">	DWORD mStartTime;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">mStartTime</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>   </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AutoTimer::AutoTimer() : mImpl(<span class="keyword">new</span> AutoTimer::Impl())</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(_WIN32) || defined(_WIN64)    </span></span><br><span class="line">    mImpl-&gt;mStartTime = GetTickCount();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	gettimeofday(&amp;(mImpl-&gt;mStartTime), <span class="literal">NULL</span>);    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line">AutoTimer::~AutoTimer()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Elapsed time: "</span> &lt;&lt; mImpl-&gt;GetElapsed() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IMG_END_NAMESPACE</span><br></pre></td></tr></table></figure>

<p>那么，什么样的函数或者数据成员应该放到Implementation类中呢？</p>
<ul>
<li>仅私有成员变量</li>
<li>私有成员变量和方法</li>
<li>公有类的所有方法，其中公有方法只是对<code>Impl</code>类中的等价方法进行简单的包装</li>
</ul>
<p>多倾向与采用在<code>Impl</code>类中放置<strong>私有成员变量和方法</strong>的逻辑。</p>
<p>Note:</p>
<p>使用<code>Pimp</code>惯用法时，应采用私有内嵌实现类，以更好地隐藏细节。只有在<code>.cpp</code>文件中其他类或者自由函数必须访问<code>Impl</code>成员时，才应采用公有内嵌类。</p>
<p>注意：<strong>复制语义</strong>，常使用<strong>智能指针</strong>建立<code>Impl</code>类的实例。</p>
<h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>只创建一个对象实例。</p>
<ul>
<li>私有化默认构造函数</li>
<li>私有化赋值和赋值构造函数</li>
<li>私有析构函数</li>
<li>返回指针或者引用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Singleton &amp;<span class="title">GetInstance</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Singleton();</span><br><span class="line">    ~Singleton();</span><br><span class="line">    Singleton(<span class="keyword">const</span> Singleton &amp;);</span><br><span class="line">    <span class="keyword">const</span> Singleton &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Singleton &amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不同编译单元中的非局部静态对象的初始化顺序是未定义的</p>
</blockquote>
<p>非局部对象是指在函数之外声明的对象，为了保证初始化顺序，在类的方法中创建静态变量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Singleton &amp;<span class="title">Singleton::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：上述实现不是线程安全的！ 通常的做法是加互斥锁。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Mutex mutex;</span><br><span class="line"><span class="function">Singleton &amp;<span class="title">Singleton::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ScopedLock <span class="title">lock</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">    <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点：由于每次调用<code>GetInstance()</code>函数时都会尝试获取锁，介绍调用时都会释放锁，这样的方法开销大。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Mutex mutex;</span><br><span class="line"><span class="function">Singleton &amp;<span class="title">Singleton::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Singleton *instance = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">nullptr</span> == instance)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">ScopedLock <span class="title">lock</span><span class="params">(&amp;mutex)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">nullptr</span> == instance)</span><br><span class="line">        &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态初始化：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Singleton &amp;<span class="title">Singleton::GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> Singleton &amp;ins = Singleton::GetInstance();</span><br></pre></td></tr></table></figure>

<p>显式API初始化，在程序已启动便首先调用<code>APIInitialize</code>函数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::mutex mut;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">APIInitialize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(mut)</span></span>;</span><br><span class="line">    Singleton::GetInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展，单一状态模式</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Monostate</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetTheAnswer</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> m_s_answer;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_s_answer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Monstate::m_s_answer = <span class="number">16</span>;</span><br></pre></td></tr></table></figure>

<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>隐藏派生类实现细节。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// renderfactory.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"render.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderFactory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">IRender *<span class="title">CreateRender</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// renderfactory.cpp</span></span><br><span class="line"><span class="comment">// 假设已经存在`OpenGLRender`, `DirectXRender`, 和 `MesaRender`三个派生类</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"renderfactory.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"openglreder.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"directxrender.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mesarender.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">IRender *<span class="title">RenderFactory::CreateRender</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(type == <span class="string">"opengl"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OpenGLRender();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(type == <span class="string">"directx"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DirectXRender();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(type == <span class="string">"mesa"</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MesaRender();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该类的缺陷是：包含了可用的派生类的硬编码信息。</p>
<p>扩展工厂示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// renderfacory.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"render.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RenderFactory</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> IRender *(*CreateCallback)();</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RegisterRender</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;type, CreateCallback cb)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UnRegisterReder</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;type)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> IRender *<span class="title">CreateRender</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;type)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, CreateCallback&gt; CallbackMap</span><br><span class="line">    <span class="keyword">static</span> CallbackMap m_renders;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// renderfactory.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"randerfactory.h"</span></span></span><br><span class="line">RenderFactory::CallBackMap RenderFactory::m_renders;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderFactory::RegisterRender</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;type, CreateCallback cb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    m_render[type] = cb;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RenderFactory::UnRegisterReder</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_render.<span class="built_in">find</span>(type) != m_render.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        m_render.erase(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">IRender *<span class="title">RenderFactory::CreateRender</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CallbackMap::iterator it = m_render.<span class="built_in">find</span>(type);</span><br><span class="line">    <span class="keyword">if</span>(it != m_render.<span class="built_in">end</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (it-&gt;second)();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserRender</span>:</span> <span class="keyword">public</span> IRender</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	~UserRender()&#123;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Render</span><span class="params">()</span> </span>&#123;	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"User render\n"</span>;&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> IRender *<span class="title">Create</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="keyword">new</span> UserRender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RenderFactory::ReginsterRender(<span class="string">"user"</span>, UserRender::Create);</span><br><span class="line">    IRender *r = RenderFactory::CreateRender(<span class="string">"user"</span>);</span><br><span class="line">    r-&gt;Render();</span><br><span class="line">    <span class="keyword">delete</span> r;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="代理、适配器和外观（包装器模式）"><a href="#代理、适配器和外观（包装器模式）" class="headerlink" title="代理、适配器和外观（包装器模式）"></a>代理、适配器和外观（包装器模式）</h3><p>结构化设计模式。按照包装器层与原始接口的差异递增程度，依次介绍以下几种：代理、适配器、外观。</p>
<ul>
<li><strong>代理模式</strong></li>
</ul>
<p>为另一个类提供了一对一的转发接口：调用代理类的FunctionA()将导致调用原始类中的FunctionA()。也就是说，代理类和原始类有相同的接口。它可以被认为是一个单一组件包装器。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Proxy() : m_orig(<span class="keyword">new</span> Original())</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    ~Proxy() </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_orig;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">DoSomething</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_orig-&gt;DoSomething(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Proxy(<span class="keyword">const</span> Proxy &amp;);</span><br><span class="line">    <span class="keyword">const</span> Proxy &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Proxy &amp;);</span><br><span class="line">    </span><br><span class="line">    Original *m_orig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种方案，增加一个共享的虚接口。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOriginal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">DoSomething</span><span class="params">(<span class="keyword">int</span> value)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Original</span> :</span> <span class="keyword">public</span> IOriginal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">DoSomething</span><span class="params">(<span class="keyword">int</span> value)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> :</span> <span class="keyword">public</span> IOriginal</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Proxy() : m_orig(<span class="keyword">new</span> Original())</span><br><span class="line">	&#123;&#125;</span><br><span class="line">	~Proxy()</span><br><span class="line">    &#123;</span><br><span class="line">    	<span class="keyword">delete</span> m_orig;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">DoSomething</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    	m_orig-&gt;DoSomething(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	Proxy(<span class="keyword">const</span> Proxy &amp;);</span><br><span class="line">    <span class="keyword">const</span> Proxy &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> Proxy &amp;);</span><br><span class="line">    </span><br><span class="line">    Original *m_orig;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>适配器模式</strong></li>
</ul>
<p>将一个类的接口转换为一个兼容的但不相同的接口。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RectangleAdapter</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RectangleAdapter(): m_rect(<span class="keyword">new</span> Rectangle())</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    ~RectangleAdapter()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_rect;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Set</span><span class="params">(<span class="keyword">float</span> x1, <span class="keyword">float</span> y1, <span class="keyword">float</span> x2, <span class="keyword">float</span> y2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> w = x2 - x1;</span><br><span class="line">        <span class="keyword">float</span> h = y2 - y1;</span><br><span class="line">        <span class="keyword">float</span> cx = w / <span class="number">2.0f</span> + x1;</span><br><span class="line">        <span class="keyword">float</span> cy = h / <span class="number">2.0f</span> + y1;</span><br><span class="line">        m_rect-&gt;setDimensions(cx, cy, w, h);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RectangleAdapter(<span class="keyword">const</span> RectangleAdapter &amp;);</span><br><span class="line">    <span class="keyword">const</span> RectangleAdapter &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> RectangleAdapter &amp;);</span><br><span class="line">    </span><br><span class="line">    Rectangle *m_rect;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>外观模式</strong></li>
</ul>
<p>为一组类提供简化的接口。外观模式和适配器模式的区别是，外观模式简化了类的结构，而适配器模式仍然保持相同的类结构。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Taxi</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">BookTaxi</span><span class="params">(<span class="keyword">int</span> people, <span class="keyword">time_t</span> pickupTime)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">ReserveTable</span><span class="params">(<span class="keyword">int</span> people, <span class="keyword">time_t</span> arrivalTime)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Theater</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">timet_t</span> <span class="title">GetShowTime</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">ReserveSeats</span><span class="params">(<span class="keyword">int</span> people, <span class="keyword">int</span> tier)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConciergeFacade</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">enum</span> ERestaurant</span><br><span class="line">    &#123;</span><br><span class="line">        RESTAURANT_YES,</span><br><span class="line">        RESTAURANT_NO,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">enum</span> ETaxi</span><br><span class="line">    &#123;</span><br><span class="line">        TAXI_YES,</span><br><span class="line">        TAXI_NO,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">time_t</span> <span class="title">BookShow</span><span class="params">(<span class="keyword">int</span> people, ERestaurant addRestaurant, ETaxi addTaxi)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h3><p>定义了一种一对多的依赖关系，让多个观察者对象同时监听某一主题对象，在主题对象状态发生变化时，会通知所有的观察者。</p>
<p><a href=".\src\ObserverPattern">示例</a></p>
<h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>装饰模式以对客户透明的方式动态地给一个对象附加更多的责任，扩展对象的功能。</p>
<p><a href=".\src\DecoratorPattern">示例</a></p>
]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>C++实现多维数组</title>
    <url>/posts/21798/</url>
    <content><![CDATA[<p>在Visual Studio 2010的版本上想要使用多维数组实现一个算法，但是，无奈<code>boost</code>提供的<code>multi_array</code>坑太多，在多维数组降维赋值时经常发生错误，<code>eigen</code>提供的只有二维矩阵，最新版本中有<code>tensor</code>，但在目前的产品代码库里用不了，opencv？太大。。。最后还是自己实现了一个，拿出来，抛砖引玉吧。</p>
<a id="more"></a>

<p>这里用到了<code>C++11</code>列表初始化；如果你的编译器比较旧（没错，我用的就是vs2010），可以使用C语言的<code>stdarg.h</code>进行不定参数解析，当然这里也有些小坑。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="comment">// custom_multi_array.hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> Dims&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultiArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	MultiArray() : mTotalDimCnt(<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(mDimCnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(T)*Dims);</span><br><span class="line">	&#125;</span><br><span class="line">	MultiArray(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; &amp;dimCnt) : mTotalDimCnt(<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		SetMemberVariable(dimCnt);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Reset</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; &amp;dimCnt)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		mTotalDimCnt = <span class="number">1</span>;</span><br><span class="line">		SetMemberVariable(dimCnt);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">size_t</span> <span class="title">GetDimCnt</span><span class="params">(<span class="keyword">size_t</span> dimIdx)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (dimIdx &lt; Dims)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> mDimCnt[dimIdx];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">size_t</span> <span class="title">GetTotalDimCnt</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> mTotalDimCnt;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">T *<span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (mContent.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &amp;mContent[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> T *<span class="title">Get</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (mContent.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> &amp;mContent[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function">T &amp;<span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; &amp;args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">size_t</span> idx = GetIndex(args);</span><br><span class="line">			<span class="keyword">return</span> mContent[idx];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::exception&amp;e)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">std</span>::invalid_argument(e.what());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">const</span> T &amp;<span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; &amp;args)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">size_t</span> idx = GetIndex(args);</span><br><span class="line">			<span class="keyword">return</span> mContent[idx];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::exception&amp;e)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">std</span>::invalid_argument(e.what());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/// Copy constructor</span></span><br><span class="line">	MultiArray&lt;T, Dims&gt;(<span class="keyword">const</span> MultiArray&lt;T, Dims&gt; &amp;lhs)</span><br><span class="line">	&#123;</span><br><span class="line">		mTotalDimCnt = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; Dims; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			mDimCnt[i] = lhs.mDimCnt[i];</span><br><span class="line">			mTotalDimCnt *= mDimCnt[i];</span><br><span class="line">		&#125;</span><br><span class="line">		mContent = lhs.mContent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/// Assignment constructor</span></span><br><span class="line">	MultiArray&lt;T, Dims&gt; &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> MultiArray&lt;T, Dims&gt; &amp;lhs)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; Dims; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			mDimCnt[i] = lhs.mDimCnt[i];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (lhs.mTotalDimCnt != mTotalDimCnt)</span><br><span class="line">		&#123;</span><br><span class="line">			mTotalDimCnt = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; Dims; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				mTotalDimCnt *= mDimCnt[i];</span><br><span class="line">			&#125;</span><br><span class="line">			mContent.resize(mTotalDimCnt);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">std</span>::copy(lhs.mContent.<span class="built_in">begin</span>(), lhs.mContent.<span class="built_in">end</span>(), mContent.<span class="built_in">begin</span>());</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">SetMemberVariable</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; &amp;dimCnt)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> exceptionPrefix = <span class="string">"GetIndex Exception! "</span>;</span><br><span class="line">		<span class="keyword">if</span> (dimCnt.<span class="built_in">size</span>() == Dims)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; Dims; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				mDimCnt[i] = dimCnt[i];</span><br><span class="line">				mTotalDimCnt *= mDimCnt[i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (mTotalDimCnt &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				mContent.resize(mTotalDimCnt, <span class="number">0</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="built_in">std</span>::invalid_argument(exceptionPrefix + <span class="string">"Dimension count error (equal 0)!"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">std</span>::invalid_argument(exceptionPrefix + <span class="string">"Dimension count size error!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">size_t</span> <span class="title">GetIndex</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">size_t</span>&gt; &amp;args)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> exceptionPrefix = <span class="string">"GetIndex Exception! "</span>;</span><br><span class="line">		<span class="comment">/// Parameters check</span></span><br><span class="line">		<span class="keyword">if</span> (args.<span class="built_in">size</span>() &gt; Dims || args.empty())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">std</span>::invalid_argument(exceptionPrefix + <span class="string">"Dimension count size error!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/// Assign to local variable</span></span><br><span class="line">		<span class="keyword">size_t</span> dimCnt[Dims] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; args.<span class="built_in">size</span>(); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			dimCnt[i] = args[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/// Get current index from args</span></span><br><span class="line">		<span class="keyword">size_t</span> idx = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; Dims; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (dimCnt[i] &gt;= mDimCnt[i])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="built_in">std</span>::invalid_argument(exceptionPrefix + <span class="string">"Dimension count error!"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Get current index corresponding element count</span></span><br><span class="line">			<span class="keyword">size_t</span>  t = <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">size_t</span> j = i + <span class="number">1</span>; j &lt; Dims; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				t *= mDimCnt[j];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// Updata index</span></span><br><span class="line">			idx += (t * dimCnt[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> idx;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">size_t</span>         mDimCnt[Dims];</span><br><span class="line">	<span class="keyword">size_t</span>         mTotalDimCnt;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; mContent;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>主函数，简单的测试和调用示例</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"custom_multi_array.hpp"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// main.cpp</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	&#123; <span class="comment">/// 构造函数</span></span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			MultiArray&lt;float, 2&gt; mat2d1(&#123; 1 &#125;);</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Construct success"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::exception&amp; e)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			MultiArray&lt;float, 2&gt; mat2d1(&#123; 1, 0 &#125;);</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Construct success"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::exception&amp; e)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			MultiArray&lt;float, 2&gt; mat2d1(&#123; 1, 1, 1 &#125;);</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Construct success"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::exception&amp; e)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">			MultiArray&lt;float, 2&gt; mat2d1(&#123; 1, 1 &#125;);</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Construct success"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (<span class="keyword">const</span> <span class="built_in">std</span>::exception&amp; e)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; e.what() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#123; <span class="comment">/// 复制，赋值构造函数</span></span><br><span class="line">		MultiArray&lt;float, 2&gt; mat2d1(&#123; 18, 2 &#125;);</span><br><span class="line">		MultiArray&lt;<span class="keyword">float</span>, <span class="number">2</span>&gt; mat2d2;</span><br><span class="line">		MultiArray&lt;float, 2&gt; mat2d3(&#123; 18, 2 &#125;);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/// 复制构造函数</span></span><br><span class="line">		MultiArray&lt;float, 2&gt; mat2d4(mat2d1);</span><br><span class="line">		<span class="comment">/// 赋值构造函数</span></span><br><span class="line">		mat2d2 = mat2d1; <span class="comment">// 大小不等</span></span><br><span class="line">		mat2d3 = mat2d1; <span class="comment">// 大小相等</span></span><br><span class="line">	&#125;</span><br><span class="line">	&#123; <span class="comment">/// 不同维度的赋值</span></span><br><span class="line">		MultiArray&lt;float, 3&gt; mat3d(&#123; 12, 18, 2 &#125;);</span><br><span class="line">		MultiArray&lt;float, 2&gt; mat2d(&#123; 18, 2 &#125;);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">memcpy</span>(mat2d.Get(), &amp;mat3d(&#123; <span class="number">5</span> &#125;), <span class="number">18</span> * <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	&#123; <span class="comment">/// 遍历输出</span></span><br><span class="line">		MultiArray&lt;float, 2&gt; mat2d(&#123; 18, 2 &#125;);</span><br><span class="line">		<span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; <span class="title">vec</span><span class="params">(<span class="number">18</span> * <span class="number">2</span>)</span></span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">18</span>*<span class="number">2</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			vec[i] = i * <span class="number">1.0f</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">memcpy</span>(mat2d.Get(), &amp;vec[<span class="number">0</span>], <span class="number">18</span> * <span class="number">2</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; mat2d.GetDimCnt(<span class="number">0</span>); i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; mat2d.GetDimCnt(<span class="number">1</span>); j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; mat2d(&#123; i, j &#125;) &lt;&lt; <span class="string">"\t"</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>C++编码总结</title>
    <url>/posts/3707651035/</url>
    <content><![CDATA[<p>总结日常开发中的一些小知识。</p>
<a id="more"></a>

<h2 id="restrict用法"><a href="#restrict用法" class="headerlink" title="restrict用法"></a><code>restrict</code>用法</h2><p>只能用于修饰指针，表示同一块内存不能被别的指针引用。有利于编译器进行优化。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *a = <span class="number">5</span>;</span><br><span class="line">    *b = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">return</span> *a + *b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rfoo</span><span class="params">(<span class="keyword">int</span> * __restrict a, <span class="keyword">int</span> * __restrict b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *a = <span class="number">5</span>;</span><br><span class="line">    *b = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">return</span> *a + *b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译出的汇编代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo:</span><br><span class="line">	.seh_endprologue</span><br><span class="line">	movl	$5, (%rcx)</span><br><span class="line">	movl	$6, (%rdx)</span><br><span class="line">	movl	(%rcx), %eax</span><br><span class="line">	addl	$6, %eax</span><br><span class="line">	ret</span><br><span class="line">	.seh_endproc</span><br><span class="line">	.p2align 4,,15</span><br><span class="line">	.globl	rfoo</span><br><span class="line">	.def	rfoo;	.scl	2;	.type	32;	.endef</span><br><span class="line">	.seh_proc	rfoo</span><br><span class="line">rfoo:</span><br><span class="line">	.seh_endprologue</span><br><span class="line">	movl	$11, %eax</span><br><span class="line">	movl	$5, (%rcx)</span><br><span class="line">	movl	$6, (%rdx)</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<h2 id="const用法"><a href="#const用法" class="headerlink" title="const用法"></a><code>const</code>用法</h2><p>如果确定一个变量是只读的，在作用域内不会改变它的值，就将其声明为<code>const</code>。注意<code>const</code>是只读的意思，而不能狭隘的认为是常量。</p>
<h2 id="extern-quot-C-quot-用法"><a href="#extern-quot-C-quot-用法" class="headerlink" title="extern &quot;C&quot;用法"></a><code>extern &quot;C&quot;</code>用法</h2><ol>
<li><p>不要在<code>extern &quot;C&quot;</code>的作用范围内中使用<code>namespace</code></p>
</li>
<li><p>不要在<code>extern &quot;C&quot;</code>范围内声明的函数签名中使用C++的特性</p>
</li>
</ol>
<p>不规范的写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Img &#123;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Function1</span><span class="params">(<span class="keyword">float</span> f1, <span class="keyword">float</span> &amp;f2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Function2</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; &amp;v, <span class="keyword">float</span> *f2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Function3</span><span class="params">(<span class="keyword">int</span> lhs)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Function3</span><span class="params">(<span class="keyword">float</span> lhs)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">float</span> *f;</span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Function4</span><span class="params">(MyStruct * myStr)</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCls</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyCls();</span><br><span class="line">    ~MyCls();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><p>尽管我们常说要禁用宏定义，但是它还是有一些优点的。比如常用的：</p>
<ol>
<li>使用宏定义进行一些调试代码的条件编译</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _USER_DEBUG</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::ofstream <span class="title">ofs</span><span class="params">(<span class="string">"out.raw"</span>, <span class="built_in">std</span>::ios::binary)</span></span>;</span><br><span class="line"><span class="keyword">if</span> (ofs.is_open())</span><br><span class="line">&#123;</span><br><span class="line">    ofs.<span class="built_in">write</span>(data, <span class="built_in">size</span>);</span><br><span class="line">    ofs.<span class="built_in">close</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// _USER_DEBUG</span></span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>函数调用的错误信息整理</li>
</ol>
<p>比如，在我们的产品代码中，在错误发生时通常需要输出错误的日志信息。之前的错误日志打印函数是这样的：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IRTFunctor::LogNotifyError</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;errorInfo, <span class="keyword">bool</span> isLogInFunction)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!m_bErrorHappenedFlag)</span><br><span class="line">	&#123;</span><br><span class="line">		m_bErrorHappenedFlag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (isLogInFunction)</span><br><span class="line">		&#123;</span><br><span class="line">			LOG2_ERROR(m_logger, errorInfo);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">uint64_t</span> svcUid = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span> (!Img::SvcUidParser::FindSvcUid(errorInfo, svcUid))</span><br><span class="line">		&#123;</span><br><span class="line">			svcUid = uidUnknown_Err1;</span><br><span class="line">			<span class="keyword">const_cast</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span> &amp;&gt;(errorInfo) = Img::SvcUidParser::SetSvcUid(errorInfo, svcUid);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">auto</span> strSvcUid = Img::SvcUidParser::GetSvcCode(svcUid);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (isLogInFunction)</span><br><span class="line">		&#123;</span><br><span class="line">			LOG2_ERROR_SVC(m_logger, svcUid, errorInfo);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		NotifyJobDetailInfo(strSvcUid);</span><br><span class="line">		NotifyError(errorInfo);</span><br><span class="line">	&#125;</span><br><span class="line">	Sleep(SleepTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样打印的一个问题是LOG中只有<code>IRTFunctor::LogNotifyError</code>函数的函数名和打印日志行，不能快速的找到错误发生的地方，改进后：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ILOG_NOTIFY_ERR</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> ILOG_NOTIFY_ERR</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ILOG_NOTIFY_ERR(LoggerPtr, SvcUid, ErrStrStream) \</span></span><br><span class="line"><span class="keyword">do</span> &#123; \</span><br><span class="line">	LOG2_ERROR(LoggerPtr, ErrStrStream); \</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">stringstream</span> ss; ss &lt;&lt; ErrStrStream; \</span><br><span class="line">	<span class="keyword">auto</span> errorInfo = Img::SvcUidParser::SetSvcUid(ss.str(), SvcUid); \</span><br><span class="line">	LOG2_ERROR_SVC(LoggerPtr, SvcUid, errorInfo); \</span><br><span class="line">	LogNotifyError(errorInfo, <span class="literal">false</span>); \</span><br><span class="line">&#125; <span class="keyword">while</span>(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> ILOG_NOTIFY_ERR_NO_SUID</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> ILOG_NOTIFY_ERR_NO_SUID</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ILOG_NOTIFY_ERR_NO_SUID(LoggerPtr, ErrStrStream) \</span></span><br><span class="line">	ILOG_NOTIFY_ERR(LoggerPtr, uidUnknown_Err, ErrStrStream)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>函数定义时抛出异常</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMG_THROW_ERROR(ErrStr, ExceptionType) \</span></span><br><span class="line">	<span class="keyword">do</span> &#123;\</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">stringstream</span> ss; ss &lt;&lt; ErrStr &lt;&lt; <span class="string">" ErrLineNumber:"</span> &lt;&lt; __LINE__; \</span><br><span class="line">		<span class="keyword">throw</span> ExceptionType(ss.str()); \</span><br><span class="line">	&#125; <span class="keyword">while</span>(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习基础</title>
    <url>/posts/3233011741/</url>
    <content><![CDATA[<p>深度学习所用到的数学知识并没有特别高深，其中最重要的是损失函数，梯度下降和激活函数。</p>
<a id="more"></a>

<h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><p>损失函数使用来估量模型和预测值和真实值之间的不一样程度，它是一个非负的实数。损失函数的值越小，表示模型越好。</p>
<h3 id="均方差损失函数"><a href="#均方差损失函数" class="headerlink" title="均方差损失函数"></a>均方差损失函数</h3><p>$$<br>MSE =<br>$$</p>
<h3 id="绝对误差"><a href="#绝对误差" class="headerlink" title="绝对误差"></a>绝对误差</h3><p>$$<br>MAE=<br>$$</p>
<h3 id="交叉熵损失函数"><a href="#交叉熵损失函数" class="headerlink" title="交叉熵损失函数"></a>交叉熵损失函数</h3><p>概率估计上定义，<br>$$<br>CrossEntropy=<br>$$<br>多分类</p>
<h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><h3 id="SGD"><a href="#SGD" class="headerlink" title="SGD"></a>SGD</h3><p>$$<br>w \leftarrow w - \eta \frac{\partial L}{\partial w}<br>$$</p>
<p><strong>Momentum</strong><br>$$<br>\nabla = \lambda {\nabla}<em>{i - 1} + \eta {\nabla}</em>{i}<br>$$</p>
<p>$$<br>w \leftarrow w - \nabla<br>$$</p>
<h3 id="RMSProp"><a href="#RMSProp" class="headerlink" title="RMSProp"></a>RMSProp</h3><p>$$<br>E[\nabla ^2] = 0.9E[\nabla ^2]_{i - 1} + 0.1 \nabla _i^2<br>$$</p>
<p>$$<br>w \leftarrow w - \frac{\eta}{\sqrt{E[\nabla ^2] + p}} \nabla_i<br>$$</p>
<h3 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h3><p><strong>相当于 RMSprop + Momentum</strong></p>
<h2 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h2><p>在神经网络的计算过程中，每层都相当于一个矩阵相乘，所以无论多少层的神经网络都是输入的线性组合。所以需要激活函数来引入非线性的因素，使得神经网络可以逼近任何非线性函数，增加模型的泛化特性。</p>
<h3 id="sigmoid"><a href="#sigmoid" class="headerlink" title="sigmoid"></a>sigmoid</h3><p>$$<br>s(x) = \frac{1}{1 + {e}^{-x}}<br>$$</p>
<p>导数为：<br>$$<br>\frac {\partial s(x)}{\partial x} = s(x)(1-s(x))<br>$$</p>
<ul>
<li>sigmoid需要进行指数运算，因此计算速度比较慢</li>
<li><em>函数的输出不是以0为中心，这样会使权重更新效率降低（Why？）</em>，<a href="https://liam.page/2018/04/17/zero-centered-active-function/" target="_blank" rel="noopener">参考</a></li>
</ul>
<p>更新效率即指函数的收敛速度，迭代次数越多，说明模型的收敛速度越慢；反之，迭代次数少，则表明收敛速度快。</p>
<p>深度学习的一般方法是反向传播，即链式法则。<br>$$<br>w \leftarrow w - \eta \frac {\partial L}{\partial w}<br>$$<br>对某一个神经元，其输入输出关系是<br>$$<br>f(\vec x;\vec w, b) = f(\sum w_i x_i + b)<br>$$<br>因此，对某一个参数$w_i$来说<br>$$<br>\frac {\partial L}{\partial w_i} = \frac {\partial L}{\partial f} \frac {\partial f}{\partial z} \frac {\partial z}{\partial w_i} = x_i \frac {\partial L}{\partial f} \frac {\partial f}{\partial z}<br>$$<br>因此，对于某一个参数，其更新过程为<br>$$<br>w_i \leftarrow w_i - \eta \frac {\partial L}{\partial w_i} = w_i - \eta x_i \frac {\partial L}{\partial f} \frac {\partial f}{\partial z}<br>$$</p>
<p>参数$w_i$的实际更新方向由$\frac {\partial L}{\partial f} \frac {\partial f}{\partial z}$决定。另外，从上式也可以看出对于任意一个$w_i$，$\frac {\partial L}{\partial f} \frac {\partial f}{\partial z}$都是常数，所以各个$w_i$更新方向的差异，完全由输入值$x_i$决定。</p>
<p><strong>以零为中心的影响：</strong></p>
<p>以二维输入为例<br>$$<br>f(\vec x;\vec w, b) = f(w_0 x_0 + w_1 x_1 + b)<br>$$<br>现在假设参数$w_0$，$w_1$的最优解是$w_0^<em>$，$w_1^</em>$，且满足条件<br>$$<br>w_0 \lt w_0^<em>, w_1 \ge w_1^</em><br>$$<br>这说明，$w_0$希望增大，而$w_1$需要适当减小。因此要求$x_0$和$x_1$的符号相反，但是在sigmoid函数中，输出值始终未正。这也就是说，如果上一级神经元采用sigmoid函数作为激活函数，那么我们总无法做到$x_0$和$x_1$符号相反。</p>
<h3 id="tanh"><a href="#tanh" class="headerlink" title="tanh"></a>tanh</h3><p>$$<br>s(x) = \frac {e^z - e^{-z}}{e^z + e^{-z}}<br>$$</p>
<p>导数为：<br>$$<br>\frac {\partial s(x)}{\partial x} = 1 - s(x)^2<br>$$</p>
<p>当输入远离坐标原点时，同sigmoid函数类似，梯度会变小，使得参数的更新速度下降。</p>
<h3 id="relu"><a href="#relu" class="headerlink" title="relu"></a>relu</h3><p>$$<br>s(x) = max(0, x)<br>$$</p>
<p>其导数为<br>$$<br>当x &gt; 0时，为1；当x &lt; 0时，为0<br>$$</p>
<h3 id="leaky-relu"><a href="#leaky-relu" class="headerlink" title="leaky relu"></a>leaky relu</h3><p>为了解决relu函数在$z \lt 0$时参数不被更新的问题，出现了leaky relu函数<br>$$<br>s(x) = x, x \ge 0; s(x) = ax, x \lt 0, a通常是一个很小的值<br>$$</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="https://arxiv.org/pdf/1609.04747.pdf" target="_blank" rel="noopener">An overview of gradient descent optimization  algorithm</a></li>
<li><a href="https://github.com/zergtant/pytorch-handbook/blob/master/chapter2/2.2-deep-learning-basic-mathematics.ipynb" target="_blank" rel="noopener">深度学习基础和数学远离</a></li>
<li><a href="https://liam.page/2018/04/17/zero-centered-active-function/" target="_blank" rel="noopener">激活函数过零点的好处</a></li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>PyTorch</tag>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title>GitHub Pages搭建个人博客</title>
    <url>/posts/9414/</url>
    <content><![CDATA[<p>使用GitHub搭建个人博客的过程虽然简单，但是期间还是踩过了一些坑，这里简单的记录一下配置的过程，以方便查找。</p>
<a id="more"></a>

<h2 id="GitHub-Pages初始化"><a href="#GitHub-Pages初始化" class="headerlink" title="GitHub Pages初始化"></a>GitHub Pages初始化</h2><h3 id="创建个人的GitHub账号"><a href="#创建个人的GitHub账号" class="headerlink" title="创建个人的GitHub账号"></a>创建个人的GitHub账号</h3><p>如用户名：<code>zhangsan</code></p>
<h3 id="在GitHub账号里新建一个和账号用户名同名的管理仓"><a href="#在GitHub账号里新建一个和账号用户名同名的管理仓" class="headerlink" title="在GitHub账号里新建一个和账号用户名同名的管理仓"></a>在GitHub账号里新建一个和账号用户名同名的管理仓</h3><p>如：<code>zhangsan.github.io</code></p>
<h3 id="设置该仓为GitHub-Page仓"><a href="#设置该仓为GitHub-Page仓" class="headerlink" title="设置该仓为GitHub Page仓"></a>设置该仓为GitHub Page仓</h3><p>步骤如下：</p>
<ul>
<li><p>在软件仓的主页面点击<code>Setting</code></p>
</li>
<li><p>找到<code>GitHub Pages</code>，点击<code>Choose a theme</code></p>
</li>
<li><p>然后随便选择一个主题，并对更改进行<code>commit</code></p>
</li>
</ul>
<h3 id="在浏览器中输入https-zhangsan-github-io便可以访问网页了。"><a href="#在浏览器中输入https-zhangsan-github-io便可以访问网页了。" class="headerlink" title="在浏览器中输入https://zhangsan.github.io便可以访问网页了。"></a>在浏览器中输入<code>https://zhangsan.github.io</code>便可以访问网页了。</h3><p>但是这样建好的网站并不美观，下面我们将会使用Hexo提供的框架对网页仓进行优化</p>
<h2 id="优化GitHub-Pages并对仓库进行管理"><a href="#优化GitHub-Pages并对仓库进行管理" class="headerlink" title="优化GitHub Pages并对仓库进行管理"></a>优化GitHub Pages并对仓库进行管理</h2><p>参考：<a href="https://www.zhihu.com/question/21193762/answer/79109280" target="_blank" rel="noopener">知乎</a>，<a href="https://hexo.io/zh-cn/docs/themes.html" target="_blank" rel="noopener">hexo</a></p>
<h3 id="搭建的流程"><a href="#搭建的流程" class="headerlink" title="搭建的流程"></a>搭建的流程</h3><ol>
<li><p><code>zhangsan.github.io</code>仓创建两个分支：<code>master</code>与<code>hexo</code></p>
</li>
<li><p>设置hexo为默认分支（因为我们只需要手动管理这个分支上的Hexo网站文件）</p>
</li>
<li><p>克隆仓库到本地，并且切换到hexo分支</p>
</li>
<li><p>参考<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo</a>安装<code>node</code>和<code>git</code>，在hexo分支上执部署hexo</p>
</li>
<li><p>修改_config.yml中的deploy参数，即将网页文件上传到<code>master</code>上</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Deployment</span><br><span class="line">## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class="line">deploy:</span><br><span class="line">  type: &#39;git&#39;</span><br><span class="line">  repo: https:&#x2F;&#x2F;github.com&#x2F;zhangsan&#x2F;zhangsan.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><p>依次执行<code>git add .</code>，<code>git commit -m &quot;...&quot;</code>，<code>git push origin hexo</code>提交网站相关的文件</p>
</li>
<li><p>执行<code>hexo g</code>，<code>hexo d</code>生成网站并部署到GitHub上</p>
</li>
</ol>
<h3 id="关于日常的改动流程"><a href="#关于日常的改动流程" class="headerlink" title="关于日常的改动流程"></a>关于日常的改动流程</h3><p>在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理。</p>
<ol>
<li><p>依次执行<code>git add .</code>，<code>git commit -m &quot;...&quot;</code>，<code>git push origin hexo</code>将改动推送到GitHub（分支应为hexo）</p>
</li>
<li><p>执行<code>hexo g</code>，<code>hexo d</code>发布网站到master分支上</p>
</li>
</ol>
<h3 id="本地资料丢失后的流程"><a href="#本地资料丢失后的流程" class="headerlink" title="本地资料丢失后的流程"></a>本地资料丢失后的流程</h3><p>当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：</p>
<ol>
<li><p>使用<code>git clone git@github.com:zhangsan/zhangsan.github.io.git</code>拷贝仓库，并切换到<code>hexo</code>分支</p>
</li>
<li><p>在本地克隆下来的文件夹根目录下，依次执行下列指令：<code>npm install hexo</code>，<code>npm install</code>，<code>npm install hexo-deployer-git</code>，（记得，不需要hexo init这条指令）。</p>
</li>
</ol>
<h2 id="next主题设置"><a href="#next主题设置" class="headerlink" title="next主题设置"></a>next主题设置</h2><p>参考：<a href="https://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">next</a></p>
<ul>
<li>在<code>Blogs</code>目录下，输入命令：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next.git themes&#x2F;next</span><br></pre></td></tr></table></figure>

<ul>
<li>打开根目录下的<code>_config.yml</code>文件，将theme字段改为next即可</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li><p>项目根目录下的<code>_config.yml</code>文件叫作站点配置文件</p>
</li>
<li><p>主题文件夹根目录下的<code>themes/next/_config.yml</code>文件叫作主题配置文件</p>
</li>
</ul>
<h3 id="给next主题添加-标签-等页面"><a href="#给next主题添加-标签-等页面" class="headerlink" title="给next主题添加[标签]等页面"></a>给next主题添加[标签]等页面</h3><p>新建页面：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd your-hexo-site</span><br><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>

<p>设置页面类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>

<p>修改菜单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F;</span><br><span class="line">  archives: &#x2F;archives</span><br><span class="line">  tags: &#x2F;tags</span><br></pre></td></tr></table></figure>

<p><strong>特别注意：*</strong></p>
<p><code>Menu</code>如果使用了图标，一定要按照下面的格式设置，小心空格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: &#x2F;|| home</span><br><span class="line">  #about: &#x2F;about&#x2F;|| user</span><br><span class="line">  tags: &#x2F;tags&#x2F;|| tags</span><br><span class="line">  categories: &#x2F;categories&#x2F;|| th</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>网站搭建</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title>卷积神经网络</title>
    <url>/posts/3329651476/</url>
    <content><![CDATA[<p>卷积神经网络是由一个或者多个卷积层和一个全连接层组成的前馈神经网络。特别适合于提取图像特征。</p>
<a id="more"></a>

<h2 id="卷积神经网络的必要性"><a href="#卷积神经网络的必要性" class="headerlink" title="卷积神经网络的必要性"></a>卷积神经网络的必要性</h2><ul>
<li><p>减少图像处理的计算量</p>
</li>
<li><p>卷积的特性特别适合于提取图像特征</p>
</li>
</ul>
<p>在一幅图像中，</p>
<ol>
<li><p>特征通常在很小的一个区域</p>
</li>
<li><p>相同的一个特征可能出现在图像中的不同位置</p>
</li>
<li><p>图像的subsampling不影响对这幅图像的理解</p>
</li>
</ol>
<p>因此我们可以简化模型参数。</p>
<h2 id="卷积神经网络的结构"><a href="#卷积神经网络的结构" class="headerlink" title="卷积神经网络的结构"></a>卷积神经网络的结构</h2><ol>
<li>卷积层（convolution layer）</li>
<li>激活函数（卷积的操作也是线性的，需要激活函数，引入非线性的因素）</li>
<li>池化（max pooling）</li>
<li>dropout</li>
<li>压扁（flatten）</li>
<li>全连接（fully connected feedforward network）</li>
</ol>
<p>1, 2, 3过程可以重复很多次。</p>
<p>对影像的处理：第一，要生成一个pattern，不需要看整张的image，你只需要看image的一小部分；第二，通用的pattern会出现在一张image的不同的区域；第三，我们可以对image做subsampling。</p>
<h3 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h3><p>卷积核大小：$f$</p>
<p>图像边界填充的的大小：$p$</p>
<p>卷积核滑动的步长：$s$</p>
<p>输入矩阵的大小：$n$</p>
<p>那么卷积后输出的个数为：<br>$$<br>\frac {n + 2 * p - f}{s} + 1 向下取整<br>$$</p>
<p>对image，移动卷积核1可以得到经过卷积后的矩阵。</p>
<p><img src=".%5Cassert%5C20200508%5Cchapter21-11.png" alt="卷积核1"></p>
<p>不同的卷积核，提取图像的不同特征，设有另外的一个卷积核2，经过运算后得到了另外一个$4 \times 4$的矩阵。红色和蓝色的矩阵合起来叫feature map。有多少个卷积核，就会得到多少个特征。（如果有100个卷积核，就会得到一个$100 \times 4 \times 4$的立方体。）</p>
<p><img src=".%5Cassert%5C20200508%5Cchapter21-12.png" alt="卷积核2"></p>
<p>convolution相当于fully connected的某些参数共享权重。</p>
<h3 id="池化"><a href="#池化" class="headerlink" title="池化"></a>池化</h3><p>池化后，每一个卷积输出的矩阵的大小为：<br>$$<br>\frac {n - f} {s} + 1<br>$$<br>这里的$n$是卷积输出的矩阵的大小。</p>
<p>max pooling的过程</p>
<p><img src=".%5Cassert%5C20200508%5Cchapter21-18.png" alt="max pooling过程"></p>
<p>max pooling的结果</p>
<p><img src=".%5Cassert%5C20200508%5Cchapter21-19.png" alt="max pooling结果"></p>
<p>设有100个卷积核，经过max pooling后就得到了一个$100 \times 2 \times2$立方体。一个卷积核就代表一个channel，即有100个channel。那么下一个卷积核的大小就是$100 \times 3 \times 3$？。</p>
<h3 id="Flatten"><a href="#Flatten" class="headerlink" title="Flatten"></a>Flatten</h3><p><img src=".%5Cassert%5C20200508%5Cchapter21-22.png" alt="flatten"></p>
<h3 id="全连接"><a href="#全连接" class="headerlink" title="全连接"></a>全连接</h3><p>由于我们的特征都是矩阵的形式，因此全连接前，还要把特征进行压扁，将这些特征变成一维的向量。</p>
<p>如果是分类，使用<code>softmax</code>作为输出；如果是回归的问题，直接使用<code>linear</code>。</p>
<p><img src=".%5Cassert%5C20200508%5Cchapter21-25.png" alt="CNN一个完整的例子"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://cs.nyu.edu/~fergus/papers/zeilerECCV2014.pdf" target="_blank" rel="noopener">为什么要用CNN</a></p>
</li>
<li><p><a href="http://yann.lecun.com/exdb/lenet/index.html" target="_blank" rel="noopener">LeNet-5, convolutional neural networks</a></p>
</li>
<li><p><a href="https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf" target="_blank" rel="noopener">AlexNet</a></p>
</li>
<li><p><a href="https://arxiv.org/pdf/1409.1556.pdf" target="_blank" rel="noopener">VGG</a></p>
</li>
<li><p><a href="https://arxiv.org/abs/1512.00567" target="_blank" rel="noopener">GoogLeNet </a></p>
</li>
<li><p><a href="https://arxiv.org/abs/1512.03385" target="_blank" rel="noopener">ResNet</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>PyTorch</tag>
        <tag>CNN</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora中配置图片上传到GitHub</title>
    <url>/posts/3927440576/</url>
    <content><![CDATA[<p>在使用markdown写作文档时，图片的插入经常是一件头疼的事情。本地图片的路径设置有一点小小的问题就会导致图片载入失败，原文件移动时图片文件也要跟随着相对移动（如果使用相对路径的话）等等的缺点。如果将图片上传到网络服务器中，只要计算机能够联网，便可以做到一劳永逸。</p>
<a id="more"></a>

<p>Typora设置图片上传的步骤分为以下5步</p>
<p><img src="./assert/20200506/1588698840.jpg" alt="Typora图片上传设置步骤"></p>
<p><a href="https://github.com/settings/tokens" target="_blank" rel="noopener">token创建</a></p>
<p>配置文件设置</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"picBed"</span>: &#123;</span><br><span class="line">    <span class="attr">"github"</span>: &#123;</span><br><span class="line">      <span class="attr">"repo"</span>: <span class="string">"用户名/图床仓库名"</span>,</span><br><span class="line">      <span class="attr">"token"</span>: <span class="string">""</span>,</span><br><span class="line">      <span class="attr">"path"</span>: <span class="string">"img/"</span>,</span><br><span class="line">      <span class="attr">"customUrl"</span>: <span class="string">"https://raw.githubusercontent.com/用户名/图床仓库名/master"</span>,</span><br><span class="line">      <span class="attr">"branch"</span>: <span class="string">"master"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"current"</span>: <span class="string">"github"</span>,</span><br><span class="line">    <span class="attr">"uploader"</span>: <span class="string">"github"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"picgoPlugins"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>软件使用</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>Typora</tag>
      </tags>
  </entry>
</search>
