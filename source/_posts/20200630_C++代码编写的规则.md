---
title: C++代码设计原则
categories:
  - 编程
tags:
  - CPP
abbrlink: 36134268
date: 2020-06-30 09:11:48
---

列举了代码编写的一些原则，遵守这些原则可以使大型项目的开发易于维护。

<!-- more -->

## 全局名字空间

### 全局数据

将全局变量非全局化：

1. 将所有的全局变量放入一个结构中
2. 然后将他们私有化并添加静态访问函数

如我们有下面的全局变量：

```C++
int size;
double scale;
const char *system;
```

可以这样修改：

```C++
// 头文件中这样声明，记得要在源文件中定义这些静态成员变量
struct Global {
    static int s_size;
    static double s_scale;
    static const char *s_system;
}
```

但是，直接访问成员变量的方式会使维护大型系统的成本极为昂贵。而且，如果`s_size`是基于另外两个更原始的值计算得到的 (`s_width`, `s_height`)，直接暴露`s_size`也是不好的。

```C++
// 单一状态
class Global {
    static int s_size;
    static double s_scale;
    static const char *s_system;
    
private:
    Global();
    
public:
    // MANIPULAORS
    static void setSize(int size) {s_size = size;}
    static void setScale(double scale) {s_scale = scale;}
    static void setSyetem(const char *system) {s_system = system;}
    
    // ACCESSORS
    static int getSize() {return s_size;}
    static double getScale() {return s_scale;}
    static const char *getSystem() {return s_system;}
}
```

### 自由函数

> 避免在.h文件的文件作用域内使用自由函数（运算符函数除外）；
>
> 在.c文件中避免使用带有外部链接的自由函数（包括运算符函数）

```C++
// bad
int getMonitorResolution();
void setSystemScale(double scaleFactor);
int isPasswordCorrect(const char *usr, cong char *pwd);
```

```C++
// fine
struct SysUtil {
    static int getMonitorResolution();
	static void setSystemScale(double scaleFactor);
	static int isPasswordCorrect(const char *usr, cong char *pwd);
}
```

### 枚举，typedef和常量数据

枚举类型，typedef和文件作用域常量数据都有内部链接，人们经常在头文件的问阿金作用域内声明常量，枚举或typedef。但，这是错误的！

```C++
// bad

// paint.h
enum Color {RED, GREEN, BLUE, ORANGE, YELLOW};

// juice.h
enum Fruit {APPLE, ORANGE, GRAPE, CRANBERRY};

// 当这样包含时就会发生错误， ORANGE 有二义性
#include "paint.h"
#include "juice.h"
#include "picture.h"
```

如果在单独的类中定义这两个枚举，我们可以很容易地使用作用域解析消除二义性问题

```C++
class Paint {
    enum Color {RED, GREEN, BLUE, ORANGE, YELLOW};
}

class Juice {
    enum Fruit {APPLE, ORANGE, GRAPE, CRANBERRY};
}
```

基于类似的原因，typedef和常量数据，也可以放在头文件的类作用域内。

```C++
// array.h
class String;

class Array {
    enum {DEFAULT_SIZE = 100};
    static const double DEFAULT_VALUE;
    static const String DEFAULT_NAME;
}

// array.c
#include "array.h"
#include "str.h"

double Array::DEFAULT_VALUE = 0.0;
String Array::DEFAULT_NAME = "111";
```

 

### 预处理宏

好的地方：

1. 包含卫哨
2. 在.c文件中（用于可移植或调试）

```C++
// bad

// theircode.h
#define GOOD 0


// ourcode.c
#include "theircode.h"
int OurClass::aFunction()
{
    enum {BAD = -1, GOOD = 0} status = GOOD;
    
    return status;
}
```

该段代码会：

```C++
int OurClass::aFunction()
{
    enum {BAD = -1, 0 = 0} status = 0;
    
    return status;
}
```

因此，就是弹出Syntax Error（语法错误）。

### 头文件中的名字

> 在一个.h文件作用域中，只应该声明类，结构体，联合体，和自由运算符函数
>
> 在.h文件作用域中只应该定义类，结构体，联合体的内联成员函数和自由运算符函数

```C++

#define PI 3.1415926						// avoid
#define MIN(X, Y) ((X) < (Y)) ? (X) : (Y)	// avoid

class DriverInit;							// fine
union Uaw;									// fine

extern int globalVariable;					// avoid
static int fileScopeVariable;				// avoid
const int BUFFER_SIZE = 256;				// avoid
enum Boolean {ZERO, ONE};					// avoid
typedef long BigInt;						// avoid

class Driver
{
	enum Color
	{
		RED,
		GREEN,
	};										// fine
	typedef int (Driver::*PMF)();			// fine
	static int s_cont;						// fine
	int d_size;								// fine

private:
	struct Pnt {
		short int x, y;
		Pnt(int x_, int y_) : 
			x(x_), y(y_) {}
	};										// fine
	friend DriverInit;						// fine

public:
	static int round(double d);				// fine

	void setSize(int size);					// fine
	int cmp(const Driver &) const;			// fine
};

static class DriverInit
{
	// ....
} driverInit;								// special case

int min(int x, int y);						// avoid

inline int max(int x, int y)
{
	return x > y ? x : y;
}											// avoid

inline 
void Driver::setSize(int size)
{
	d_size = size;
}											// fine

ostream &operator<<(ostream &o, const Driver &d);
											// fine

```

### 包含卫哨

