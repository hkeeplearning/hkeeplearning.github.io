---
title: 常用设计模式总结
categories:
  - 编程
tags:
  - 设计模式
  - CPP
abbrlink: 2602918917
date: 2019-12-11 09:11:48
---

设计模式是编码的一种经验总结，通过设计模式我们可以实现通用性好，易于扩展，方便维护的接口。

<!-- more -->

## 设计模式

### `Pimpl`惯用法

隐藏内部细节。

```C++
// autotimer.h
#if defined(_WIN32) || defined(_WIN64)
# include <windows.h>
#else
#include <sys/time.h>
#endif

IMG_BEGIN_NAMESPACE

class AutoTimer
{
public:
    AutoTimer();
    ~AutoTimer();
    
private:
    double GetElapsed() const;
#if defined(_WIN32) || defined(_WIN64)
	DWORD mStartTime;
#else
	struct timeval mStartTime;
#endif    
}

IMG_END_NAMESPACE
```

实现这个类的目的只是为了获取对象从构造到销毁之间的运行时间，与程序在是什么平台上跑完全没有关系吧。在这个头文件中暴露了太多的细节，破坏了接口的简洁性。

```C++
// autotimer.h
IMG_BEGIN_NAMESPACE
    
#include <memory>
    
class AutoTimer
{
public:
    AutoTimer();
    ~AutoTimer();
    
private:
    class Impl; //! 声明为私有，在CPP文件里的其他类或者自由函数不能访问Impl
    Impl *mImpl;
}

IMG_END_NAMESPACE

#endif // IMG_SYSTEM_STATE_HPP_H_
    
// autotimer.cpp
#include <iostream>
#if defined(_WIN32) || defined(_WIN64)
# include <windows.h>
#else
#include <sys/time.h>
#endif
    
IMG_BEGIN_NAMESPACE
    
class AutoTimer::Impl
{
public:
	double GetElapsed() const;
#if defined(_WIN32) || defined(_WIN64)
	DWORD mStartTime;
#else
	struct timeval mStartTime;
#endif   
}

AutoTimer::AutoTimer() : mImpl(new AutoTimer::Impl())
{
#if defined(_WIN32) || defined(_WIN64)    
    mImpl->mStartTime = GetTickCount();
#else
	gettimeofday(&(mImpl->mStartTime), NULL);    
#endif
}
AutoTimer::~AutoTimer()
{
    std::cout << "Elapsed time: " << mImpl->GetElapsed() << std::endl;
}

IMG_END_NAMESPACE
```

那么，什么样的函数或者数据成员应该放到Implementation类中呢？

- 仅私有成员变量
- 私有成员变量和方法
- 公有类的所有方法，其中公有方法只是对`Impl`类中的等价方法进行简单的包装

多倾向与采用在`Impl`类中放置**私有成员变量和方法**的逻辑。

Note:

使用`Pimp`惯用法时，应采用私有内嵌实现类，以更好地隐藏细节。只有在`.cpp`文件中其他类或者自由函数必须访问`Impl`成员时，才应采用公有内嵌类。

注意：**复制语义**，常使用**智能指针**建立`Impl`类的实例。

### 单例模式

只创建一个对象实例。

- 私有化默认构造函数
- 私有化赋值和赋值构造函数
- 私有析构函数
- 返回指针或者引用

```C++
class Singleton
{
public:
    static Singleton &GetInstance();
    
private:
    Singleton();
    ~Singleton();
    Singleton(const Singleton &);
    const Singleton &operator=(const Singleton &);
}

```

> 不同编译单元中的非局部静态对象的初始化顺序是未定义的

非局部对象是指在函数之外声明的对象，为了保证初始化顺序，在类的方法中创建静态变量。

```C++
Singleton &Singleton::GetInstance()
{
    static Singleton instance;
    return instance;
}
```

注意：上述实现不是线程安全的！ 通常的做法是加互斥锁。

```C++
static Mutex mutex;
Singleton &Singleton::GetInstance()
{
    ScopedLock lock(&mutex);
    static Singleton instance;
    return instance;
}
```

缺点：由于每次调用`GetInstance()`函数时都会尝试获取锁，介绍调用时都会释放锁，这样的方法开销大。

```C++
static Mutex mutex;
Singleton &Singleton::GetInstance()
{
    static Singleton *instance = nullptr;
    if (nullptr == instance)
    {
        ScopedLock lock(&mutex);
        if(nullptr == instance)
        {
            instance = new Singleton();
        }
    }
    return *instance;
}
```

静态初始化：

```C++
Singleton &Singleton::GetInstance()
{
    static Singleton instance;
    return instance;
}
static Singleton &ins = Singleton::GetInstance();
```

显式API初始化，在程序已启动便首先调用`APIInitialize`函数：

```C++
static std::mutex mut;

void APIInitialize()
{
    std::lock_guard<std::mutex> lock(mut);
    Singleton::GetInstance();
}
```

扩展，单一状态模式

```C++
class Monostate
{
public:
    int GetTheAnswer() const { return m_s_answer;}
    
private:
    static int m_s_answer;
}

int Monstate::m_s_answer = 16;
```

### 工厂模式

隐藏派生类实现细节。

```C++
// renderfactory.h
#include "render.h"
#include <string>

class RenderFactory
{
public:
    IRender *CreateRender(const std::string &type);
}
```

```C++
// renderfactory.cpp
// 假设已经存在`OpenGLRender`, `DirectXRender`, 和 `MesaRender`三个派生类
#include "renderfactory.h"
#include "openglreder.h"
#include "directxrender.h"
#include "mesarender.h"

IRender *RenderFactory::CreateRender(const std::string &type)
{
    if(type == "opengl")
    {
        return new OpenGLRender();
    }
    if(type == "directx")
    {
        return new DirectXRender();
    }
    if(type == "mesa")
    {
        return new MesaRender();
    }
    return NULL;
}
```

该类的缺陷是：包含了可用的派生类的硬编码信息。

扩展工厂示例：

```C++
// renderfacory.h
#include "render.h"
#include <string>
#include <map>

class RenderFactory
{
public:
    typedef IRender *(*CreateCallback)();
    static void RegisterRender(const std::string &type, CreateCallback cb);
    static void UnRegisterReder(const std::string &type);
    static IRender *CreateRender(const std::string &type);

private:
    typedef std::map<std::string, CreateCallback> CallbackMap
    static CallbackMap m_renders;
}

// renderfactory.cpp
#include "randerfactory.h"
RenderFactory::CallBackMap RenderFactory::m_renders;
void RenderFactory::RegisterRender(const std::string &type, CreateCallback cb)
{
    m_render[type] = cb;
}
void RenderFactory::UnRegisterReder(const std::string &type)
{
    if(m_render.find(type) != m_render.end())
    {
        m_render.erase(type);
    }
}
IRender *RenderFactory::CreateRender(const std::string &type)
{
    CallbackMap::iterator it = m_render.find(type);
    if(it != m_render.end())
    {
        return (it->second)();
    }
    return NULL;
}
```

```C++
class UserRender: public IRender
{
public:
	~UserRender(){}
	void Render() {	std::cout << "User render\n";}
	static IRender *Create()
    {
    	return new UserRender();
    }
}
```

```C++
int main(void)
{
    RenderFactory::ReginsterRender("user", UserRender::Create);
    IRender *r = RenderFactory::CreateRender("user");
    r->Render();
    delete r;
    
    return 0;
}
```

### 代理、适配器和外观（包装器模式）

结构化设计模式。按照包装器层与原始接口的差异递增程度，依次介绍以下几种：代理、适配器、外观。

- **代理模式**

为另一个类提供了一对一的转发接口：调用代理类的FunctionA()将导致调用原始类中的FunctionA()。也就是说，代理类和原始类有相同的接口。它可以被认为是一个单一组件包装器。

```C++
class Proxy
{
public:
    Proxy() : m_orig(new Original())
    {
        
    }
    ~Proxy() 
    {
        delete m_orig;
    }
    
    bool DoSomething(int value)
    {
        return m_orig->DoSomething(value);
    }
    
private:
    Proxy(const Proxy &);
    const Proxy &operator=(const Proxy &);
    
    Original *m_orig;
}

```

另一种方案，增加一个共享的虚接口。

```C++
class IOriginal
{
public:
    virtual bool DoSomething(int value) = 0;
}

class Original : public IOriginal
{
public:
	bool DoSomething(int value);
}

class Proxy : public IOriginal
{
public:
	Proxy() : m_orig(new Original())
	{}
	~Proxy()
    {
    	delete m_orig;
    }
    
    bool DoSomething(int value)
    {
    	m_orig->DoSomething(value);
    }
    
private:
	Proxy(const Proxy &);
    const Proxy &operator=(const Proxy &);
    
    Original *m_orig;
}
```

- **适配器模式**

将一个类的接口转换为一个兼容的但不相同的接口。

```C++
class RectangleAdapter
{
public:
    RectangleAdapter(): m_rect(new Rectangle())
    {}
    ~RectangleAdapter()
    {
        delete m_rect;
    }
    
    void Set(float x1, float y1, float x2, float y2)
    {
        float w = x2 - x1;
        float h = y2 - y1;
        float cx = w / 2.0f + x1;
        float cy = h / 2.0f + y1;
        m_rect->setDimensions(cx, cy, w, h);
    }
    
private:
    RectangleAdapter(const RectangleAdapter &);
    const RectangleAdapter &operator=(const RectangleAdapter &);
    
    Rectangle *m_rect;
}
```

- **外观模式**

为一组类提供简化的接口。外观模式和适配器模式的区别是，外观模式简化了类的结构，而适配器模式仍然保持相同的类结构。

```C++
class Taxi
{
public:
    bool BookTaxi(int people, time_t pickupTime);
};

class Restaurant
{
public:
    bool ReserveTable(int people, time_t arrivalTime);
};

class Theater
{
public:
    timet_t GetShowTime();
    bool ReserveSeats(int people, int tier);
}

class ConciergeFacade
{
public:
    enum ERestaurant
    {
        RESTAURANT_YES,
        RESTAURANT_NO,
    };
    enum ETaxi
    {
        TAXI_YES,
        TAXI_NO,
    };
    time_t BookShow(int people, ERestaurant addRestaurant, ETaxi addTaxi);
}
```

### 观察者

定义了一种一对多的依赖关系，让多个观察者对象同时监听某一主题对象，在主题对象状态发生变化时，会通知所有的观察者。

[示例](.\src\ObserverPattern)

### 装饰模式

装饰模式以对客户透明的方式动态地给一个对象附加更多的责任，扩展对象的功能。

[示例](.\src\DecoratorPattern)