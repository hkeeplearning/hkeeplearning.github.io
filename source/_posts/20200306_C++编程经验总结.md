---
title: C++编码总结
categories:
  - 编程
tags:
  - CPP
abbrlink: 3707651035
date: 2020-03-06 15:11:48
---

总结日常开发中的一些小知识。

<!-- more -->

## `restrict`用法

只能用于修饰指针，表示同一块内存不能被别的指针引用。有利于编译器进行优化。

示例：

```C++
int foo(int *a, int *b)
{
    *a = 5;
    *b = 6;
    return *a + *b;
}

int rfoo(int * __restrict a, int * __restrict b)
{
    *a = 5;
    *b = 6;
    return *a + *b;
}
```

编译出的汇编代码：

```s
foo:
	.seh_endprologue
	movl	$5, (%rcx)
	movl	$6, (%rdx)
	movl	(%rcx), %eax
	addl	$6, %eax
	ret
	.seh_endproc
	.p2align 4,,15
	.globl	rfoo
	.def	rfoo;	.scl	2;	.type	32;	.endef
	.seh_proc	rfoo
rfoo:
	.seh_endprologue
	movl	$11, %eax
	movl	$5, (%rcx)
	movl	$6, (%rdx)
	ret
```

## `const`用法

如果确定一个变量是只读的，在作用域内不会改变它的值，就将其声明为`const`。注意`const`是只读的意思，而不能狭隘的认为是常量。

## `extern "C"`用法

1. 不要在`extern "C"`的作用范围内中使用`namespace`

2. 不要在`extern "C"`范围内声明的函数签名中使用C++的特性

不规范的写法：

```C++
#ifdef __cplusplus
extern "C" {
#endif

namespace Img {
    
bool Function1(float f1, float &f2);

bool Function2(std::vector<float> &v, float *f2);

bool Function3(int lhs);
bool Function3(float lhs);
    
struct MyStruct
{
    float *f;
    int len;
};
bool Function4(MyStruct * myStr);
    
class MyCls
{
public:
    MyCls();
    ~MyCls();
}

}
    
#ifdef __cplusplus
}
#endif
```

## 宏定义

尽管我们常说要禁用宏定义，但是它还是有一些优点的。比如常用的：

1. 使用宏定义进行一些调试代码的条件编译

```C++
#ifdef _USER_DEBUG
std::ofstream ofs("out.raw", std::ios::binary);
if (ofs.is_open())
{
    ofs.write(data, size);
    ofs.close();
}
#endif // _USER_DEBUG
```

2. 函数调用的错误信息整理

比如，在我们的产品代码中，在错误发生时通常需要输出错误的日志信息。之前的错误日志打印函数是这样的：

```C++
void IRTFunctor::LogNotifyError(const std::string &errorInfo, bool isLogInFunction)
{
	if (!m_bErrorHappenedFlag)
	{
		m_bErrorHappenedFlag = true;

		if (isLogInFunction)
		{
			LOG2_ERROR(m_logger, errorInfo);
		}

		uint64_t svcUid = 0;
		if (!Img::SvcUidParser::FindSvcUid(errorInfo, svcUid))
		{
			svcUid = uidUnknown_Err1;
			const_cast<std::string &>(errorInfo) = Img::SvcUidParser::SetSvcUid(errorInfo, svcUid);
		}
		auto strSvcUid = Img::SvcUidParser::GetSvcCode(svcUid);

		if (isLogInFunction)
		{
			LOG2_ERROR_SVC(m_logger, svcUid, errorInfo);
		}

		NotifyJobDetailInfo(strSvcUid);
		NotifyError(errorInfo);
	}
	Sleep(SleepTime);
}
```

这样打印的一个问题是LOG中只有`IRTFunctor::LogNotifyError`函数的函数名和打印日志行，不能快速的找到错误发生的地方，改进后：

```C++
#ifdef ILOG_NOTIFY_ERR
#undef ILOG_NOTIFY_ERR
#endif
#define ILOG_NOTIFY_ERR(LoggerPtr, SvcUid, ErrStrStream) \
do { \
	LOG2_ERROR(LoggerPtr, ErrStrStream); \
	std::stringstream ss; ss << ErrStrStream; \
	auto errorInfo = Img::SvcUidParser::SetSvcUid(ss.str(), SvcUid); \
	LOG2_ERROR_SVC(LoggerPtr, SvcUid, errorInfo); \
	LogNotifyError(errorInfo, false); \
} while(false)

#ifdef ILOG_NOTIFY_ERR_NO_SUID
#undef ILOG_NOTIFY_ERR_NO_SUID
#endif
#define ILOG_NOTIFY_ERR_NO_SUID(LoggerPtr, ErrStrStream) \
	ILOG_NOTIFY_ERR(LoggerPtr, uidUnknown_Err, ErrStrStream)
```

3. 函数定义时抛出异常

```C++
#define IMG_THROW_ERROR(ErrStr, ExceptionType) \
	do {\
		std::stringstream ss; ss << ErrStr << " ErrLineNumber:" << __LINE__; \
		throw ExceptionType(ss.str()); \
	} while(false)
```

